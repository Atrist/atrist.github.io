---
title: 计算右侧小于当前元素的个数
date: 2021-01-16
tags:
  - leetcode
summary: 刷算法,向前进
author: Atrist
---

## 参考资料

1. [leetcode 高级算法](https://leetcode-cn.com/leetbook/detail/top-interview-questions-hard/)
2. [计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/description/)
## 计算右侧小于当前元素的个数
给定一个整数数组 `nums`，按要求返回一个新数组 `counts`。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
### 示例：
```bash
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```
### 提示：
- `0 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

## 方法一：离散化树状数组
### 预备知识

「树状数组」是一种可以动态维护序列前缀和的数据结构，它的功能是：
- 单点更新 `update(i, v)`： 把序列 i 位置的数加上一个值 v，在该题中 `v = 1`
- 区间查询 `query(i)`： 查询序列 $[1 \cdots i]$ 区间的区间和，即 i 位置的前缀和

修改和查询的时间代价都是 $O(\log n)$，其中 nn 为需要维护前缀和的序列的长度。
### 思路与算法

记题目给定的序列为 a，我们规定 $a_i$的取值集合为 a 的「值域」。我们用桶来表示值域中的每一个数，桶中记录这些数字出现的次数。假设 $a = \{5, 5, 2, 3, 6\}$，那么遍历这个序列得到的桶是这样的：
```bash
index  ->  1 2 3 4 5 6 7 8 9
value  ->  0 1 1 0 2 1 0 0 0
```
###  转化为动态维护前缀和问题
记 `value` 序列为 v，我们可以看出它第 i - 1 位的前缀和表示「有多少个数比 i 小」。那么我们可以从后往前遍历序列 a，记当前遍历到的元素为 $a_i$，我们把 $a_i$对应的桶的值自增 1，记 $a_i = pa$，把 v 序列 p - 1 位置的前缀和加入到答案中算贡献。为什么这么做是对的呢，因为我们在循环的过程中，我们把原序列分成了两部分，后半部部分已经遍历过（已入桶），前半部分是待遍历的（未入桶），那么我们求到的 p - 1 位置的前缀和就是「已入桶」的元素中比 p 小的元素的个数总和。**这种动态维护前缀和的问题我们可以用「树状数组」来解决**。
### 用离散化优化空间

我们显然可以用数组来实现这个桶，可问题是如果 $a_i$中有很大的元素，比如 $10^9$，我们就要开一个大小为 $10^9$的桶，内存中是存不下的。这个桶数组中很多位置是 0，有效位置是稀疏的，我们要想一个办法让有效的位置全聚集到一起，减少无效位置的出现，这个时候我们就需要用到一个方法——离散化。**离散化的方法有很多，但是目的是一样的，即把原序列的值域映射到一个连续的整数区间，并保证它们的偏序关系不变**。 这里我们将原数组去重后排序，原数组每个数映射到去重排序后这个数对应位置的下标，我们称这个下标为这个对应数字的 $\rm id$。已知数字获取 $\rm id$ 可以在去重排序后的数组里面做二分查找，已知 $\rm id$ 获取数字可以直接把 $\rm id$ 作为下标访问去重排序数组的对应位置。

### 代码
```js

```